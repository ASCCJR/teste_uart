# UART Protocol Bridge - FPGA Colorlight i9

## Descrição do Projeto

Este projeto implementa uma ponte de protocolo (Protocol Bridge) utilizando um FPGA Colorlight i9. O sistema é composto por três componentes principais:

- **Controle Remoto**: BitDogLab #1
- **Unidade de Processamento**: FPGA Colorlight i9
- **Atuador**: BitDogLab #2

## Como Funciona

1. A **BitDogLab #1** lê o estado de seus botões e envia comandos via protocolo UART
2. O **FPGA** recebe esses comandos e os traduz em tempo real
3. O FPGA controla um pino de saída GPIO (Alto/Baixo)
4. A **BitDogLab #2** lê esse pino GPIO e acende ou apaga seu LED de acordo

## Objetivo

Este projeto é um exemplo fundamental de como FPGAs podem ser usados para "traduzir" entre diferentes interfaces de comunicação em hardware.

## Arquivos do Projeto

- `top.v` - Módulo principal do projeto
- `uart_rx.v` - Módulo de recepção UART
- `bridge.lpf` - Arquivo de constraints do FPGA
- `readme` - Este arquivo

## Status Atual

**Parte 1 - Implementação UART**

Se der certo, então conseguimos "ensinar" o FPGA a entender o protocolo UART vindo da BitDogLab #1. Portanto, o FPGA agora possui uma interface de recepção UART funcional.

---

## Próximos Passos - Migração para I2C

### Arquitetura Proposta

```
[BitDogLab #1] --- (Protocolo I2C) ---> [FPGA] --- (Protocolo GPIO) ---> [BitDogLab #2]
```

### 1️⃣ BitDogLab #1 (O Transmissor)

**🔄 Novo Papel**: Mestre I2C (em vez de transmissor UART)

#### 📝 Mudanças Necessárias

| Aspecto | Detalhes |
|---------|----------|
| **💻 Novo Código** | Programa em C usando a biblioteca I2C do Pico SDK |
| **🔌 Novas Conexões** | • **SDA** (dados) → GP0 do conector I2C0<br>• **SCL** (clock) → GP1 do conector I2C0 |
| **📡 Novo Comando** | Em vez de enviar `'1'` via UART, envia comando I2C<br>📨 Exemplo: `"Dispositivo 0x42, receba: 0x01"` |

### 2️⃣ FPGA (A Ponte)

**🔄 Novo Papel**: Escravo I2C (em vez de receptor UART)

#### 📝 Mudanças Necessárias

<table>
<tr>
<td><strong>🔧 Arquivos</strong></td>
<td>
<code>uart_rx.v</code> ❌ → <code>i2c_slave.v</code> ✅
</td>
</tr>
<tr>
<td><strong>💾 Novo Código Verilog</strong></td>
<td>
Módulo I2C slave com as seguintes funcionalidades:<br>
• Monitorar pinos <strong>SDA</strong> e <strong>SCL</strong> para detectar "start" e "stop bits"<br>
• Ouvir o barramento e reconhecer o endereço do FPGA (ex: <code>0x42</code>)<br>
• Enviar "acknowledge bit" (ACK) de volta ao mestre no tempo exato<br>
• Receber byte de dados (<code>0x01</code>) após o endereço
</td>
</tr>
<tr>
<td><strong>⚡ Lógica de Saída</strong></td>
<td>
Similar ao atual:<br>
• Se dado recebido = <code>0x01</code> → 💡 Liga LED<br>
• Se dado recebido = <code>0x00</code> → ⚫ Desliga LED
</td>
</tr>
</table>

### 3️⃣ BitDogLab #2 (O Receptor)

> ✅ **Sem alterações necessárias**

A BitDogLab #2 não se importa com a origem do sinal GPIO (ponte UART ou I2C). O código permanece o mesmo, garantindo compatibilidade retroativa.

---

## 🛠️ Tecnologias Utilizadas

- **Hardware**: FPGA Colorlight i9, BitDogLab
- **Linguagem**: Verilog HDL
- **Protocolos**: UART, GPIO, I2C (planejado)
- **Ferramentas**: Yosys, NextPNR, OpenFPGALoader

## 📚 Recursos Adicionais

- 📖 [Documentação UART](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter)
- 📖 [Documentação I2C](https://www.i2c-bus.org/)
- 🔧 [Colorlight i9 FPGA](https://github.com/wuxx/Colorlight-FPGA-Projects)

## 📄 Licença

Este projeto é open-source e está disponível para fins educacionais.

---

<div align="center">
  
**Desenvolvido com ❤️ usando FPGA Colorlight i9**
  
⭐ Se este projeto foi útil, considere dar uma estrela!

</div>