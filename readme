# UART Protocol Bridge - FPGA Colorlight i9

## DescriÃ§Ã£o do Projeto

Este projeto implementa uma ponte de protocolo (Protocol Bridge) utilizando um FPGA Colorlight i9. O sistema Ã© composto por trÃªs componentes principais:

- **Controle Remoto**: BitDogLab #1
- **Unidade de Processamento**: FPGA Colorlight i9
- **Atuador**: BitDogLab #2

## Como Funciona

1. A **BitDogLab #1** lÃª o estado de seus botÃµes e envia comandos via protocolo UART
2. O **FPGA** recebe esses comandos e os traduz em tempo real
3. O FPGA controla um pino de saÃ­da GPIO (Alto/Baixo)
4. A **BitDogLab #2** lÃª esse pino GPIO e acende ou apaga seu LED de acordo

## Objetivo

Este projeto Ã© um exemplo fundamental de como FPGAs podem ser usados para "traduzir" entre diferentes interfaces de comunicaÃ§Ã£o em hardware.

## Arquivos do Projeto

- `top.v` - MÃ³dulo principal do projeto
- `uart_rx.v` - MÃ³dulo de recepÃ§Ã£o UART
- `bridge.lpf` - Arquivo de constraints do FPGA
- `readme` - Este arquivo

## Status Atual

**Parte 1 - ImplementaÃ§Ã£o UART**

Se der certo, entÃ£o conseguimos "ensinar" o FPGA a entender o protocolo UART vindo da BitDogLab #1. Portanto, o FPGA agora possui uma interface de recepÃ§Ã£o UART funcional.

---

## PrÃ³ximos Passos - MigraÃ§Ã£o para I2C

### Arquitetura Proposta

```
[BitDogLab #1] --- (Protocolo I2C) ---> [FPGA] --- (Protocolo GPIO) ---> [BitDogLab #2]
```

### 1ï¸âƒ£ BitDogLab #1 (O Transmissor)

**ğŸ”„ Novo Papel**: Mestre I2C (em vez de transmissor UART)

#### ğŸ“ MudanÃ§as NecessÃ¡rias

| Aspecto | Detalhes |
|---------|----------|
| **ğŸ’» Novo CÃ³digo** | Programa em C usando a biblioteca I2C do Pico SDK |
| **ğŸ”Œ Novas ConexÃµes** | â€¢ **SDA** (dados) â†’ GP0 do conector I2C0<br>â€¢ **SCL** (clock) â†’ GP1 do conector I2C0 |
| **ğŸ“¡ Novo Comando** | Em vez de enviar `'1'` via UART, envia comando I2C<br>ğŸ“¨ Exemplo: `"Dispositivo 0x42, receba: 0x01"` |

### 2ï¸âƒ£ FPGA (A Ponte)

**ğŸ”„ Novo Papel**: Escravo I2C (em vez de receptor UART)

#### ğŸ“ MudanÃ§as NecessÃ¡rias

<table>
<tr>
<td><strong>ğŸ”§ Arquivos</strong></td>
<td>
<code>uart_rx.v</code> âŒ â†’ <code>i2c_slave.v</code> âœ…
</td>
</tr>
<tr>
<td><strong>ğŸ’¾ Novo CÃ³digo Verilog</strong></td>
<td>
MÃ³dulo I2C slave com as seguintes funcionalidades:<br>
â€¢ Monitorar pinos <strong>SDA</strong> e <strong>SCL</strong> para detectar "start" e "stop bits"<br>
â€¢ Ouvir o barramento e reconhecer o endereÃ§o do FPGA (ex: <code>0x42</code>)<br>
â€¢ Enviar "acknowledge bit" (ACK) de volta ao mestre no tempo exato<br>
â€¢ Receber byte de dados (<code>0x01</code>) apÃ³s o endereÃ§o
</td>
</tr>
<tr>
<td><strong>âš¡ LÃ³gica de SaÃ­da</strong></td>
<td>
Similar ao atual:<br>
â€¢ Se dado recebido = <code>0x01</code> â†’ ğŸ’¡ Liga LED<br>
â€¢ Se dado recebido = <code>0x00</code> â†’ âš« Desliga LED
</td>
</tr>
</table>

### 3ï¸âƒ£ BitDogLab #2 (O Receptor)

> âœ… **Sem alteraÃ§Ãµes necessÃ¡rias**

A BitDogLab #2 nÃ£o se importa com a origem do sinal GPIO (ponte UART ou I2C). O cÃ³digo permanece o mesmo, garantindo compatibilidade retroativa.

---

## ğŸ› ï¸ Tecnologias Utilizadas

- **Hardware**: FPGA Colorlight i9, BitDogLab
- **Linguagem**: Verilog HDL
- **Protocolos**: UART, GPIO, I2C (planejado)
- **Ferramentas**: Yosys, NextPNR, OpenFPGALoader

## ğŸ“š Recursos Adicionais

- ğŸ“– [DocumentaÃ§Ã£o UART](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter)
- ğŸ“– [DocumentaÃ§Ã£o I2C](https://www.i2c-bus.org/)
- ğŸ”§ [Colorlight i9 FPGA](https://github.com/wuxx/Colorlight-FPGA-Projects)

## ğŸ“„ LicenÃ§a

Este projeto Ã© open-source e estÃ¡ disponÃ­vel para fins educacionais.

---

<div align="center">
  
**Desenvolvido com â¤ï¸ usando FPGA Colorlight i9**
  
â­ Se este projeto foi Ãºtil, considere dar uma estrela!

</div>